// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc2830.CommandRobotSample.subsystems;

import org.usfirst.frc2830.CommandRobotSample.Robot;
import org.usfirst.frc2830.CommandRobotSample.RobotMap;
import org.usfirst.frc2830.CommandRobotSample.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 *
 */
/**
 * @author RoboTiger
 *
 */
/**
 * @author RoboTiger
 *
 */
/**
 * @author RoboTiger
 *
 */
/**
 * @author RoboTiger
 *
 */
/**
 * @author RoboTiger
 *
 */
public class DriveTrain extends Subsystem {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	SpeedController speedController1 = RobotMap.driveTrainSpeedController1;
	SpeedController speedController2 = RobotMap.driveTrainSpeedController2;
	SpeedController speedController3 = RobotMap.driveTrainSpeedController3;
	SpeedController speedController4 = RobotMap.driveTrainSpeedController4;
	RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;
	Gyro gyro1 = RobotMap.driveTrainGyro1;
	Encoder quadratureEncoder1 = RobotMap.driveTrainQuadratureEncoder1;
	Encoder quadratureEncoder2 = RobotMap.driveTrainQuadratureEncoder2;
	Encoder quadratureEncoder3 = RobotMap.driveTrainQuadratureEncoder3;
	Encoder quadratureEncoder4 = RobotMap.driveTrainQuadratureEncoder4;
	/**
	 * 
	 */
	double deadband = .2;
	double gyroCorrection = -.15;
	private double rotatingSpeed;
	boolean holdHeading = true;
	// the setting of what is "forward"
	private double setPoint;
	private boolean wasRotating;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new FieldCentricDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}


	/**
	 *  Runs the robot in Field Centric mode
	 */
	public void fieldCentricDrive() {
		robotDrive.mecanumDrive_Cartesian(
				Robot.oi.driverJoystick.getAxis(Joystick.AxisType.kX),
				Robot.oi.driverJoystick.getAxis(Joystick.AxisType.kY),
				this.getRotatingSpeed(), this.getGyroAngle());
	}

	
	/**
	 *  Runs the robot in robot centric mode
	 */
	public void robotCentricDrive() {
		robotDrive.mecanumDrive_Cartesian(
				Robot.oi.driverJoystick.getAxis(Joystick.AxisType.kX),
				Robot.oi.driverJoystick.getAxis(Joystick.AxisType.kY),
				this.getRotatingSpeed(), 0);
	}
	/**
	 * If Robot is not rotating, return 0
	 * 
	 * If it is rotating, return the twist value from the joystick
	 * 
	 * @return The rotating speed
	 */
	double getRotatingSpeed() {

		if (this.isRotating()) {								// it IS rotating
				this.setWasRotating(true);
				return Robot.oi.driverJoystick.getTwist();
			} else {
				if (this.wasRotating()){						// if it was rotating, reset the setpoint to the current forward heading
				this.setSetPoint();
				this.setWasRotating(false);
				return 0;	
			} else {													// This is NOT rotating, and it wasn't before.												
				if (Math.abs(this.getGyroAngle() - this.getSetPoint()) < deadband){     // The gyro is within the deadband range of the setpoint
					return 0;
		    	} else {
		    		if (this.getGyroAngle() - this.getSetPoint() < 0) {
		    			return gyroCorrection; 		//Didn't quite go far enough
		    		}else {
		    			return -gyroCorrection;		//Went too far
		    		}
		    	}
			}
			}
	}
	
	/**
	 * Is the robot Rotating?
	 * 
	 * @return whether or not the robot is currently rotating
	 */
	boolean isRotating(){
		if (Math.abs(Robot.oi.driverJoystick.getTwist()) > deadband){
			return true;
		} else {
			return false;
		}
		
	}

	
	/**
	 * @return was the robot rotating last time?
	 */
	boolean wasRotating() {
		return wasRotating;

	}

	/**
	 * Hey, the robot was rotating last time! True? or False, you tell me.
	 * @param rotating
	 */
	void setWasRotating(boolean rotating) {
		wasRotating = rotating;
	}

	/**
	 * Return the angle from the Gyro
	 * 
	 * @return Gyro Angle
	 */
	double getGyroAngle() {
		return this.gyro1.getAngle();
	}

	/**
	 * @return The Setpoint of the robot
	 */
	double getSetPoint() {
		return setPoint;
	}

	/**
	 *  Set the setpoint to the current Gyro angle
	 */
	void setSetPoint() {
		this.setPoint = this.getGyroAngle();
	}

}
